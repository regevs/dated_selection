initialize() {
	defineConstant("genomeSize", 1000);
	defineConstant("N",1000);
	defineConstant("U",0.002);
	defineConstant("s",-0.001);
	defineConstant("N_generations",20000);
	defineConstant("run",1);

	initializeMutationRate(U/genomeSize); 
	initializeTreeSeq(); // record trees for recapitation and/or adding neutral mutations later
	initializeMutationType("m1", 1.0, distributionType="f", 1.0); // neutral U_n
	initializeMutationType("m2", 1.0, distributionType="f", s); // selected U_d
	// args are: name, dominance (1 for clarity in haploid), f for "fixed", s
	m1.convertToSubstitution = T;
	m1.mutationStackPolicy = "l";
	
	initializeGenomicElementType("g1", c(m1,m2), c(0.0,1.0)); // last is relative freqs of mutations
	// set last entry to 0,1 if you want no neutral mutations at this point	
	initializeGenomicElement(g1, 0, genomeSize);
	initializeRecombinationRate(0); // haploid
	}
	

// generating initial population
1 early() {
	sim.addSubpop("p1", N);
	p1.setCloningRate(1.0); // haploid
}

// necessary for haploid, copied straight from manual
late() { 
	// remove any new mutations added to the disabled diploid genomes
	sim.subpopulations.individuals.genome2.removeMutations();
	// remove mutations in the haploid genomes that have fixed
	muts1 = sim.mutationsOfType(m1);
	freqs = sim.mutationFrequencies(NULL, muts1);
	if (any(freqs == 0.5))
	sim.subpopulations.genomes.removeMutations(muts1[freqs == 0.5], T);
}

// sample individuals:

1 late(){sim.treeSeqRememberIndividuals(sample(sim.subpopulations.individuals,10));}

10000 late() {sim.treeSeqRememberIndividuals(sample(sim.subpopulations.individuals,10));}

20000 late() {sim.treeSeqRememberIndividuals(sample(sim.subpopulations.individuals,10));}

// output
20000 late() {
out="pytest.trees";
sim.treeSeqOutput(out,simplify = F);
sim.simulationFinished();
}
